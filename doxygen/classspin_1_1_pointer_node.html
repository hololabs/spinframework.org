<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SPIN Framework: spin::PointerNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SPIN Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>spin</b>      </li>
      <li class="navelem"><a class="el" href="classspin_1_1_pointer_node.html">PointerNode</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="classspin_1_1_pointer_node.html#pub-types">Public Types</a> &#124;
<a href="classspin_1_1_pointer_node.html#pub-methods">Public Member Functions</a> &#124;
<a href="classspin_1_1_pointer_node.html#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<h1>spin::PointerNode Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="spin::PointerNode" --><!-- doxytag: inherits="spin::RayNode" -->
<p>An interaction node that reports intersections with other nodes in the scene (only those that are have interactionMode &gt; 0)  
<a href="classspin_1_1_pointer_node.html#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_pointer_node_8h_source.html">PointerNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for spin::PointerNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classspin_1_1_pointer_node.png" usemap="#spin::PointerNode_map" alt=""/>
  <map id="spin::PointerNode_map" name="spin::PointerNode_map">
<area href="classspin_1_1_ray_node.html" alt="spin::RayNode" shape="rect" coords="0,112,137,136"/>
<area href="classspin_1_1_group_node.html" alt="spin::GroupNode" shape="rect" coords="0,56,137,80"/>
<area href="classspin_1_1_referenced_node.html" alt="spin::ReferencedNode" shape="rect" coords="0,0,137,24"/>
</map>
 </div></div>

<p><a href="classspin_1_1_pointer_node-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>GrabMode</b> { <b>ORIENTATION_LOCK</b>, 
<b>RELATIVE</b>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f833d670ff9f90dd2897d5fda072784"></a><!-- doxytag: member="spin::PointerNode::PointerNode" ref="a7f833d670ff9f90dd2897d5fda072784" args="(SceneManager *sceneManager, const char *initID)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PointerNode</b> (<a class="el" href="classspin_1_1_scene_manager.html">SceneManager</a> *sceneManager, const char *initID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#a10ada6336321f2d0da8f18466f14df17">callbackUpdate</a> (osg::NodeVisitor *nv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classspin_1_1_group_node.html">GroupNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#a5c49e9a27d865800a1fe3de21616f059">getNodeFromIntersections</a> (int index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">osgManipulator::Dragger *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#add1cef94670d348bcdfe3702546e1415">getDraggerFromIntersections</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#a41f6e82923ffb718446a0229faa2b0f0">manipulate</a> (int b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a156a1a7c2eb8cf7192dc5e7ef3972ce5"></a><!-- doxytag: member="spin::PointerNode::getManipulate" ref="a156a1a7c2eb8cf7192dc5e7ef3972ce5" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>getManipulate</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#ae8f7efc374d6793cc7ef191e63bc26a0">lockToTarget</a> (const char *nodeToLock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#a058f198ce9bc448bfbceff27061b56ed">setManipulator</a> (const char *manipulatorType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#af750fb7dcfb0285784a81d56f9698ae8">setGrabMode</a> (GrabMode mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae57b6485c48ab919de038733ebfcb82d"></a><!-- doxytag: member="spin::PointerNode::getGrabMode" ref="ae57b6485c48ab919de038733ebfcb82d" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>getGrabMode</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#aac400a4de30975fd9b76344c0010d250">grab</a> (int b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#aea6df04ea9d34bb29e30edf7f366d48f">translateOnPointer</a> (float f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#a94c0bd6aed9609d67735e93c8ae3f99b">rotateOnPointer</a> (float f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#a4bd2aa6581463e1eea16a0d310763fd2">getGrab</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; lo_message &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#acdbdb7083de339032f19547ccb0368df">getState</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#ae956cf77c5b91aea9d815d63854af298">applyManipulation</a> (osg::Matrix mat, osg::Vec3 start, osg::Vec3 end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40b22604a4f1aaf95da004da3b058357"></a><!-- doxytag: member="spin::PointerNode::applyGrab" ref="a40b22604a4f1aaf95da004da3b058357" args="(osg::Matrix mat)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyGrab</b> (osg::Matrix mat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_pointer_node.html#a40a85bc7eb715129210cbc8e6be90ee0">reportIntersections</a> ()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>An interaction node that reports intersections with other nodes in the scene (only those that are have interactionMode &gt; 0) </p>
<p><a class="el" href="classspin_1_1_pointer_node.html" title="An interaction node that reports intersections with other nodes in the scene (only those that are hav...">PointerNode</a> reports a list of all nodes with which the ray is intersecting (in order of closest to furthest). It can also be used to grab and manipulate nodes. The grabber allows the first node to be "grabbed" and moved around, while the manipulate method checks the intersection for draggers in the scene and invokes a motion command on a dragger. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae956cf77c5b91aea9d815d63854af298"></a><!-- doxytag: member="spin::PointerNode::applyManipulation" ref="ae956cf77c5b91aea9d815d63854af298" args="(osg::Matrix mat, osg::Vec3 start, osg::Vec3 end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::PointerNode::applyManipulation </td>
          <td>(</td>
          <td class="paramtype">osg::Matrix&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">osg::Vec3&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">osg::Vec3&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks intersections for draggers and if so, we apply the drag events </p>

</div>
</div>
<a class="anchor" id="a10ada6336321f2d0da8f18466f14df17"></a><!-- doxytag: member="spin::PointerNode::callbackUpdate" ref="a10ada6336321f2d0da8f18466f14df17" args="(osg::NodeVisitor *nv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::PointerNode::callbackUpdate </td>
          <td>(</td>
          <td class="paramtype">osg::NodeVisitor *&#160;</td>
          <td class="paramname"><em>nv</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For nodes that require regular programmatic control, there is a callback that is evaluated with every refresh. This function can thus be used for animations, or any other periodic updates.</p>
<p>Note that changes to the scene graph structure (eg, moving/deleting nodes should NOT be done within this callback because traversals stacks will become corrupted. The technique is rather to enable a flag and then do the actual change in the SceneManager::updateGraph() method. </p>

<p>Reimplemented from <a class="el" href="classspin_1_1_group_node.html#a27b2cf96910b6d433fc6bfee9cd71da2">spin::GroupNode</a>.</p>

</div>
</div>
<a class="anchor" id="add1cef94670d348bcdfe3702546e1415"></a><!-- doxytag: member="spin::PointerNode::getDraggerFromIntersections" ref="add1cef94670d348bcdfe3702546e1415" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osgManipulator::Dragger * spin::PointerNode::getDraggerFromIntersections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return the first dragger in the intersection list </p>

</div>
</div>
<a class="anchor" id="a4bd2aa6581463e1eea16a0d310763fd2"></a><!-- doxytag: member="spin::PointerNode::getGrab" ref="a4bd2aa6581463e1eea16a0d310763fd2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spin::PointerNode::getGrab </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether there is a valid node that is currently 'grabbed' </dd></dl>

</div>
</div>
<a class="anchor" id="a5c49e9a27d865800a1fe3de21616f059"></a><!-- doxytag: member="spin::PointerNode::getNodeFromIntersections" ref="a5c49e9a27d865800a1fe3de21616f059" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classspin_1_1_group_node.html">GroupNode</a> * spin::PointerNode::getNodeFromIntersections </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the first <a class="el" href="classspin_1_1_group_node.html" title="A basic node to manage translation/orientation/scale of a subgraph. Allows for grouping of nodes...">GroupNode</a> encountered with interaction mode greater than passthru </p>

</div>
</div>
<a class="anchor" id="acdbdb7083de339032f19547ccb0368df"></a><!-- doxytag: member="spin::PointerNode::getState" ref="acdbdb7083de339032f19547ccb0368df" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; lo_message &gt; spin::PointerNode::getState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each subclass of <a class="el" href="classspin_1_1_referenced_node.html" title="The base class for all SPIN scene graph nodes.">ReferencedNode</a>, we override the <a class="el" href="classspin_1_1_pointer_node.html#acdbdb7083de339032f19547ccb0368df">getState()</a> method to fill the vector with the correct set of methods for this particular node </p>

<p>Reimplemented from <a class="el" href="classspin_1_1_ray_node.html#ac949b00f6ce1a475bf6064a888b3c99f">spin::RayNode</a>.</p>

</div>
</div>
<a class="anchor" id="aac400a4de30975fd9b76344c0010d250"></a><!-- doxytag: member="spin::PointerNode::grab" ref="aac400a4de30975fd9b76344c0010d250" args="(int b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::PointerNode::grab </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The grab method selects the closest intersected node and temporarily attaches it to the pointer, allowing it to inherit any translation or rotation offsets.</p>
<p>Notes:</p>
<ul>
<li>Only nodes derived from <a class="el" href="classspin_1_1_group_node.html" title="A basic node to manage translation/orientation/scale of a subgraph. Allows for grouping of nodes...">GroupNode</a> can be grabbed.</li>
<li>If no node is intersected, the grab won't do anything.</li>
<li>The node is re-attached to it's original parent when released, so don't delete the parent in the meantime</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>A boolean grab indicator (1 to grab, 0 to release) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8f7efc374d6793cc7ef191e63bc26a0"></a><!-- doxytag: member="spin::PointerNode::lockToTarget" ref="ae8f7efc374d6793cc7ef191e63bc26a0" args="(const char *nodeToLock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::PointerNode::lockToTarget </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nodeToLock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This looks to see if there is a node being pointed at, and if so, it tells the nodeToLock to lock it's orientation to always point at that target. Useful for cameras. </p>

</div>
</div>
<a class="anchor" id="a41f6e82923ffb718446a0229faa2b0f0"></a><!-- doxytag: member="spin::PointerNode::manipulate" ref="a41f6e82923ffb718446a0229faa2b0f0" args="(int b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::PointerNode::manipulate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p><a class="el" href="classspin_1_1_pointer_node.html#add1cef94670d348bcdfe3702546e1415">getDraggerFromIntersections()</a>) </p>
</p>

</div>
</div>
<a class="anchor" id="a40a85bc7eb715129210cbc8e6be90ee0"></a><!-- doxytag: member="spin::PointerNode::reportIntersections" ref="a40a85bc7eb715129210cbc8e6be90ee0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::PointerNode::reportIntersections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reports the list of intersected nodes (server-side only) </p>

</div>
</div>
<a class="anchor" id="a94c0bd6aed9609d67735e93c8ae3f99b"></a><!-- doxytag: member="spin::PointerNode::rotateOnPointer" ref="a94c0bd6aed9609d67735e93c8ae3f99b" args="(float f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::PointerNode::rotateOnPointer </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rotates the currently grabbed node (if there is one) around the pointer axis.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The amount by which to rotate around the pointer ray (in degrees) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af750fb7dcfb0285784a81d56f9698ae8"></a><!-- doxytag: member="spin::PointerNode::setGrabMode" ref="af750fb7dcfb0285784a81d56f9698ae8" args="(GrabMode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::PointerNode::setGrabMode </td>
          <td>(</td>
          <td class="paramtype">GrabMode&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the OrientationMode of the node, which will be applied after every transformation. </p>

</div>
</div>
<a class="anchor" id="a058f198ce9bc448bfbceff27061b56ed"></a><!-- doxytag: member="spin::PointerNode::setManipulator" ref="a058f198ce9bc448bfbceff27061b56ed" args="(const char *manipulatorType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::PointerNode::setManipulator </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>manipulatorType</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>We can call setManipulator and pass the name of a dragger, and the pointer will enable the dragger on the current <a class="el" href="classspin_1_1_group_node.html" title="A basic node to manage translation/orientation/scale of a subgraph. Allows for grouping of nodes...">GroupNode</a> that it is currently pointing at. If the pointer is not intersecting with any node, this will set the dragger on the last manipulated node; this was found to be a desired behaviour instead of constantly ensuring an intersection whenever the user wanted to use a different manipulator. </p>

<p>Reimplemented from <a class="el" href="classspin_1_1_group_node.html">spin::GroupNode</a>.</p>

</div>
</div>
<a class="anchor" id="aea6df04ea9d34bb29e30edf7f366d48f"></a><!-- doxytag: member="spin::PointerNode::translateOnPointer" ref="aea6df04ea9d34bb29e30edf7f366d48f" args="(float f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::PointerNode::translateOnPointer </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Slides the currently grabbed node (if there is one) along the pointer axis (ie, increasing or decreasing the distance).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The amount by which to slide (positive values slide the attached node AWAY from the pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="_pointer_node_8h_source.html">PointerNode.h</a></li>
<li>src/spin/PointerNode.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
