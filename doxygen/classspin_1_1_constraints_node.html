<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SPIN Framework: spin::ConstraintsNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SPIN Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>spin</b>      </li>
      <li class="navelem"><a class="el" href="classspin_1_1_constraints_node.html">ConstraintsNode</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="classspin_1_1_constraints_node.html#pub-types">Public Types</a> &#124;
<a href="classspin_1_1_constraints_node.html#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>spin::ConstraintsNode Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="spin::ConstraintsNode" --><!-- doxytag: inherits="spin::GroupNode" -->
<p>A node with constrained motion.  
<a href="classspin_1_1_constraints_node.html#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_constraints_node_8h_source.html">ConstraintsNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for spin::ConstraintsNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classspin_1_1_constraints_node.png" usemap="#spin::ConstraintsNode_map" alt=""/>
  <map id="spin::ConstraintsNode_map" name="spin::ConstraintsNode_map">
<area href="classspin_1_1_group_node.html" alt="spin::GroupNode" shape="rect" coords="0,56,137,80"/>
<area href="classspin_1_1_referenced_node.html" alt="spin::ReferencedNode" shape="rect" coords="0,0,137,24"/>
<area href="classspin_1_1_user_node.html" alt="spin::UserNode" shape="rect" coords="0,168,137,192"/>
</map>
 </div></div>

<p><a href="classspin_1_1_constraints_node-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#a0c998608ea3ef67e60d4a35dad1483c8">ConstraintMode</a> { <br/>
&#160;&#160;<a class="el" href="classspin_1_1_constraints_node.html#a0c998608ea3ef67e60d4a35dad1483c8a514372ff60303a5cf671a5cd25d06036">BASIC</a>, 
<a class="el" href="classspin_1_1_constraints_node.html#a0c998608ea3ef67e60d4a35dad1483c8ac6a52adc23c83e024d25cbfbbb563222">DROP</a>, 
<a class="el" href="classspin_1_1_constraints_node.html#a0c998608ea3ef67e60d4a35dad1483c8a6072e9c312ff3791f7590093f2252934">COLLIDE</a>, 
<a class="el" href="classspin_1_1_constraints_node.html#a0c998608ea3ef67e60d4a35dad1483c8abf57e526fb12139a6314266ccfa04180">BOUNCE</a>, 
<br/>
&#160;&#160;<a class="el" href="classspin_1_1_constraints_node.html#a0c998608ea3ef67e60d4a35dad1483c8a68baf5fc94ae22d837efd51a238c9da5">STICK</a>, 
<a class="el" href="classspin_1_1_constraints_node.html#a0c998608ea3ef67e60d4a35dad1483c8afaeedc34befe891c0d0291fba2d7b033">COLLIDE_THRU</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#a0d2a5cba4cfe3a4b14706aa80e1cf79a">CollisionMode</a> { <a class="el" href="classspin_1_1_constraints_node.html#a0d2a5cba4cfe3a4b14706aa80e1cf79aa135b832cb1762318d49d8f107fd178da">POINT</a>, 
<a class="el" href="classspin_1_1_constraints_node.html#a0d2a5cba4cfe3a4b14706aa80e1cf79aa826f48a7ae486287cf1fc472b229014e">BOUNDING_SPHERE</a>, 
<a class="el" href="classspin_1_1_constraints_node.html#a0d2a5cba4cfe3a4b14706aa80e1cf79aa183832369c4da12fd2dcc3fe5071c892">MESH</a>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f651e48c50a9b13ea9e294954b689c5"></a><!-- doxytag: member="spin::ConstraintsNode::ConstraintsNode" ref="a7f651e48c50a9b13ea9e294954b689c5" args="(SceneManager *sceneManager, const char *initID)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>ConstraintsNode</b> (<a class="el" href="classspin_1_1_scene_manager.html">SceneManager</a> *sceneManager, const char *initID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#ada7fe0a149089422aa3e9880da50a654">callbackUpdate</a> (osg::NodeVisitor *nv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#a325c42b39e388e3f8bccdea317c5a442">setTarget</a> (const char *id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#a1a424ba5ff153c029c8134eba254c5cc">getTarget</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#a35f59fdab88adaa0ec229803d1d66f77">setConstraintMode</a> (<a class="el" href="classspin_1_1_constraints_node.html#a0c998608ea3ef67e60d4a35dad1483c8">ConstraintMode</a> m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#ad5f8a0c785086cb59effc03c9717ead4">getConstraintMode</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#ae770247e7c1fd6302f941c6733bfdc18">setCubeSize</a> (float xScale, float yScale, float zScale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#a748a01fc46d9fd1d4d0f16e803ef3552">setCubeOffset</a> (float x, float y, float z)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">osg::Vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#ab105a5ea2797b2be8acc7479fb356f4d">getCubeSize</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">osg::Vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#a9c60b34c1f64981687130c7535dd9b21">getCubeOffset</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#ad7e96f4c21f5a0bc360a1d2822b24746">setTranslation</a> (float x, float y, float z)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#a7b067c5a09c6a7ae8571708f3658088d">translate</a> (float x, float y, float z)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#a2cd7e272b0e62c6d02ddc897f411bf0c">move</a> (float x, float y, float z)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#aefefbb26d7e85100e204c80029fab33b">applyConstrainedTranslation</a> (osg::Vec3 v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; lo_message &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspin_1_1_constraints_node.html#a28a27957ebba3121911c77c381a65cce">getState</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A node with constrained motion. </p>
<p>This node operates much like <a class="el" href="classspin_1_1_group_node.html" title="A basic node to manage translation/orientation/scale of a subgraph. Allows for grouping of nodes...">GroupNode</a>, allowing children to be attached, but motion is constrained in a certain way.</p>
<p>Foremost, there is one BASIC form of constraint where motion of the node is bound within a cubic volume.</p>
<p>Additionally, there are several ConstraintModes, where properties of a target node are used to limit movement of this node. For example, the node will only move along the surface of the target, or bounce off.</p>
<p>One needs to specify the target node for some of these special modes to work. </p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a0d2a5cba4cfe3a4b14706aa80e1cf79a"></a><!-- doxytag: member="spin::ConstraintsNode::CollisionMode" ref="a0d2a5cba4cfe3a4b14706aa80e1cf79a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classspin_1_1_constraints_node.html#a0d2a5cba4cfe3a4b14706aa80e1cf79a">spin::ConstraintsNode::CollisionMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0d2a5cba4cfe3a4b14706aa80e1cf79aa135b832cb1762318d49d8f107fd178da"></a><!-- doxytag: member="POINT" ref="a0d2a5cba4cfe3a4b14706aa80e1cf79aa135b832cb1762318d49d8f107fd178da" args="" -->POINT</em>&nbsp;</td><td>
<p>When computing collisions with other surfaces, only the origin point (local 0,0,0) of is considered. This is by far the most efficient method. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0d2a5cba4cfe3a4b14706aa80e1cf79aa826f48a7ae486287cf1fc472b229014e"></a><!-- doxytag: member="BOUNDING_SPHERE" ref="a0d2a5cba4cfe3a4b14706aa80e1cf79aa826f48a7ae486287cf1fc472b229014e" args="" -->BOUNDING_SPHERE</em>&nbsp;</td><td>
<p>When computing collisions with other surfaces, we use the local bounding sphere of this node to check the collision. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0d2a5cba4cfe3a4b14706aa80e1cf79aa183832369c4da12fd2dcc3fe5071c892"></a><!-- doxytag: member="MESH" ref="a0d2a5cba4cfe3a4b14706aa80e1cf79aa183832369c4da12fd2dcc3fe5071c892" args="" -->MESH</em>&nbsp;</td><td>
<p>The most expensive method of computing collisions, the entire mesh is traversed to check if any parts of the mesh has collided with others in the scene. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c998608ea3ef67e60d4a35dad1483c8"></a><!-- doxytag: member="spin::ConstraintsNode::ConstraintMode" ref="a0c998608ea3ef67e60d4a35dad1483c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classspin_1_1_constraints_node.html#a0c998608ea3ef67e60d4a35dad1483c8">spin::ConstraintsNode::ConstraintMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enumerator containing all of the constraint modes available </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0c998608ea3ef67e60d4a35dad1483c8a514372ff60303a5cf671a5cd25d06036"></a><!-- doxytag: member="BASIC" ref="a0c998608ea3ef67e60d4a35dad1483c8a514372ff60303a5cf671a5cd25d06036" args="" -->BASIC</em>&nbsp;</td><td>
<p>The node is just constrained within a cubic volume. Important note: the BASIC constraint is always maintained, even if another mode is chosen. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0c998608ea3ef67e60d4a35dad1483c8ac6a52adc23c83e024d25cbfbbb563222"></a><!-- doxytag: member="DROP" ref="a0c998608ea3ef67e60d4a35dad1483c8ac6a52adc23c83e024d25cbfbbb563222" args="" -->DROP</em>&nbsp;</td><td>
<p>The node sits on the surface of the target subgraph (ie, follows local Z-axis down until it finds an intersection with the target surface) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0c998608ea3ef67e60d4a35dad1483c8a6072e9c312ff3791f7590093f2252934"></a><!-- doxytag: member="COLLIDE" ref="a0c998608ea3ef67e60d4a35dad1483c8a6072e9c312ff3791f7590093f2252934" args="" -->COLLIDE</em>&nbsp;</td><td>
<p>A form of collision detection, where the node is blocked (and slides along) the target's surface. Note: sliding only works when the target is locally convex. Concavities are not checked, and may position the node on the other side of the target's surface. Use STICK instead for non-convex geometries. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0c998608ea3ef67e60d4a35dad1483c8abf57e526fb12139a6314266ccfa04180"></a><!-- doxytag: member="BOUNCE" ref="a0c998608ea3ef67e60d4a35dad1483c8abf57e526fb12139a6314266ccfa04180" args="" -->BOUNCE</em>&nbsp;</td><td>
<p>A form of collision detection, where the node reflects off the parent's surface, and travels in the reflected direction (ie, the orientation of the node is changed). Note: this only works when node is moved using the "translate" command. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0c998608ea3ef67e60d4a35dad1483c8a68baf5fc94ae22d837efd51a238c9da5"></a><!-- doxytag: member="STICK" ref="a0c998608ea3ef67e60d4a35dad1483c8a68baf5fc94ae22d837efd51a238c9da5" args="" -->STICK</em>&nbsp;</td><td>
<p>Equivalent to COLLIDE, but without sliding. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0c998608ea3ef67e60d4a35dad1483c8afaeedc34befe891c0d0291fba2d7b033"></a><!-- doxytag: member="COLLIDE_THRU" ref="a0c998608ea3ef67e60d4a35dad1483c8afaeedc34befe891c0d0291fba2d7b033" args="" -->COLLIDE_THRU</em>&nbsp;</td><td>
<p>A fake constraint, which can be used to simply report when a collision occurs. The event reported is the same as that for COLLIDE. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aefefbb26d7e85100e204c80029fab33b"></a><!-- doxytag: member="spin::ConstraintsNode::applyConstrainedTranslation" ref="aefefbb26d7e85100e204c80029fab33b" args="(osg::Vec3 v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::ConstraintsNode::applyConstrainedTranslation </td>
          <td>(</td>
          <td class="paramtype">osg::Vec3&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A pseudo-recursive function that checks if a translation results in one or more intersections with the target node. If no intersection, this method defaults to just a setTranslation call. Otherwise, it will do a setTranslation for the collision point, and call itself again until there are no collisions left. </p>

</div>
</div>
<a class="anchor" id="ada7fe0a149089422aa3e9880da50a654"></a><!-- doxytag: member="spin::ConstraintsNode::callbackUpdate" ref="ada7fe0a149089422aa3e9880da50a654" args="(osg::NodeVisitor *nv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::ConstraintsNode::callbackUpdate </td>
          <td>(</td>
          <td class="paramtype">osg::NodeVisitor *&#160;</td>
          <td class="paramname"><em>nv</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For nodes that require regular programmatic control, there is a callback that is evaluated with every refresh. This function can thus be used for animations, or any other periodic updates.</p>
<p>Note that changes to the scene graph structure (eg, moving/deleting nodes should NOT be done within this callback because traversals stacks will become corrupted. The technique is rather to enable a flag and then do the actual change in the SceneManager::updateGraph() method. </p>

<p>Reimplemented from <a class="el" href="classspin_1_1_group_node.html#a27b2cf96910b6d433fc6bfee9cd71da2">spin::GroupNode</a>.</p>

<p>Reimplemented in <a class="el" href="classspin_1_1_user_node.html#a30bacda49ee478fe603d6ef2ea85e4b9">spin::UserNode</a>.</p>

</div>
</div>
<a class="anchor" id="ad5f8a0c785086cb59effc03c9717ead4"></a><!-- doxytag: member="spin::ConstraintsNode::getConstraintMode" ref="ad5f8a0c785086cb59effc03c9717ead4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spin::ConstraintsNode::getConstraintMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>int which is converted to the type of constraint currently set on the node (drawn from constraintMode enum) </dd></dl>

</div>
</div>
<a class="anchor" id="a9c60b34c1f64981687130c7535dd9b21"></a><!-- doxytag: member="spin::ConstraintsNode::getCubeOffset" ref="a9c60b34c1f64981687130c7535dd9b21" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osg::Vec3 spin::ConstraintsNode::getCubeOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Vec indicating the offset of the cubic BASIC constraint from its local coordinate system. </dd></dl>

</div>
</div>
<a class="anchor" id="ab105a5ea2797b2be8acc7479fb356f4d"></a><!-- doxytag: member="spin::ConstraintsNode::getCubeSize" ref="ab105a5ea2797b2be8acc7479fb356f4d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">osg::Vec3 spin::ConstraintsNode::getCubeSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Vec3 indicating the size of the cubic BASIC constraint </dd></dl>

</div>
</div>
<a class="anchor" id="a28a27957ebba3121911c77c381a65cce"></a><!-- doxytag: member="spin::ConstraintsNode::getState" ref="a28a27957ebba3121911c77c381a65cce" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; lo_message &gt; spin::ConstraintsNode::getState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each subclass of <a class="el" href="classspin_1_1_referenced_node.html" title="The base class for all SPIN scene graph nodes.">ReferencedNode</a>, we override the <a class="el" href="classspin_1_1_constraints_node.html#a28a27957ebba3121911c77c381a65cce">getState()</a> method to fill the vector with the correct set of methods for this particular node </p>

<p>Reimplemented from <a class="el" href="classspin_1_1_group_node.html#ae1325b91e622456912bd00e9e3de664b">spin::GroupNode</a>.</p>

<p>Reimplemented in <a class="el" href="classspin_1_1_user_node.html#a052f5cea8ccd3c28953457e69d03385f">spin::UserNode</a>.</p>

</div>
</div>
<a class="anchor" id="a1a424ba5ff153c029c8134eba254c5cc"></a><!-- doxytag: member="spin::ConstraintsNode::getTarget" ref="a1a424ba5ff153c029c8134eba254c5cc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spin::ConstraintsNode::getTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>t_symbol which indicates the target ID on which the constraints are based (Note: The target could also be a group node). </dd></dl>

</div>
</div>
<a class="anchor" id="a2cd7e272b0e62c6d02ddc897f411bf0c"></a><!-- doxytag: member="spin::ConstraintsNode::move" ref="a2cd7e272b0e62c6d02ddc897f411bf0c" args="(float x, float y, float z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::ConstraintsNode::move </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The move command adds a relative translation with respect to the node's current orientation. That is, the node will translate along it's direction vector by the supplied number of units. </p>

<p>Reimplemented from <a class="el" href="classspin_1_1_group_node.html#ad60b53ce938ab55a2a4bdb5806cb1584">spin::GroupNode</a>.</p>

</div>
</div>
<a class="anchor" id="a35f59fdab88adaa0ec229803d1d66f77"></a><!-- doxytag: member="spin::ConstraintsNode::setConstraintMode" ref="a35f59fdab88adaa0ec229803d1d66f77" args="(ConstraintMode m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::ConstraintsNode::setConstraintMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classspin_1_1_constraints_node.html#a0c998608ea3ef67e60d4a35dad1483c8">ConstraintMode</a>&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the node's constraint mode, based on the types in constrainMode enum (see enum for details) </p>

</div>
</div>
<a class="anchor" id="a748a01fc46d9fd1d4d0f16e803ef3552"></a><!-- doxytag: member="spin::ConstraintsNode::setCubeOffset" ref="a748a01fc46d9fd1d4d0f16e803ef3552" args="(float x, float y, float z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::ConstraintsNode::setCubeOffset </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the center of the BASIC constraint cube with respect to the local coordinate system (either the parent object or the world grid). </p>

</div>
</div>
<a class="anchor" id="ae770247e7c1fd6302f941c6733bfdc18"></a><!-- doxytag: member="spin::ConstraintsNode::setCubeSize" ref="ae770247e7c1fd6302f941c6733bfdc18" args="(float xScale, float yScale, float zScale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::ConstraintsNode::setCubeSize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>zScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the size of the imaginary cube beyond which the constrained node cannot pass, when constraint type BASIC is set. </p>

</div>
</div>
<a class="anchor" id="a325c42b39e388e3f8bccdea317c5a442"></a><!-- doxytag: member="spin::ConstraintsNode::setTarget" ref="a325c42b39e388e3f8bccdea317c5a442" args="(const char *id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::ConstraintsNode::setTarget </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets a target whose properties can be used to limit movement of this node, depending on the type on constraint selected. (this should be a model node or shape node, or a group node ideally not too complex, because large amounts of triangles will lead to excessive calculations) </p>

</div>
</div>
<a class="anchor" id="ad7e96f4c21f5a0bc360a1d2822b24746"></a><!-- doxytag: member="spin::ConstraintsNode::setTranslation" ref="ad7e96f4c21f5a0bc360a1d2822b24746" args="(float x, float y, float z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::ConstraintsNode::setTranslation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The local translation offset for this node with respect to it's parent </p>

<p>Reimplemented from <a class="el" href="classspin_1_1_group_node.html#acef1a227cad6c3efa1b14674151cc5f0">spin::GroupNode</a>.</p>

</div>
</div>
<a class="anchor" id="a7b067c5a09c6a7ae8571708f3658088d"></a><!-- doxytag: member="spin::ConstraintsNode::translate" ref="a7b067c5a09c6a7ae8571708f3658088d" args="(float x, float y, float z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spin::ConstraintsNode::translate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The translate command increments the node's current translation values (ie, it's position in the scene with respect to it's parent) </p>

<p>Reimplemented from <a class="el" href="classspin_1_1_group_node.html#a9b0e074536ee837d745c0d708b6822e0">spin::GroupNode</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="_constraints_node_8h_source.html">ConstraintsNode.h</a></li>
<li>src/spin/ConstraintsNode.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
